% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsp_de_analysis_parallel.R
\name{dsp_de_analysis_parallel}
\alias{dsp_de_analysis_parallel}
\title{DSP differential expression analysis (parallel)}
\usage{
dsp_de_analysis_parallel(
  de_results = NULL,
  norm_counts,
  samp_notes,
  grouping_var,
  base_level,
  control_var,
  de_dir,
  n_processors = 4,
  the_formula = "classic",
  show_pb = TRUE,
  min_sample_size = 3
)
}
\arguments{
\item{\code{de_results}}{object that can be one of the following:
\enumerate{
   \item{NULL. If not provided, the differential expression analysis will run}
   \item{object of type \code{character} specifying the location of the previous saved DE results}
   \item{object of type \code{data.frame} providing the loaded DE results}
}}

\item{\code{norm_counts}}{is \code{data.frame} containing the normalized count data
to be analyzed. Each row corresponds to a gene of interest. The first column is assumed
to be labeled 'Gene'. Each additional column corresponds to a Sample_ID. Sample_ID values
have a matching row in the annotations objects (see \code{samp_notes} argument below).}

\item{\code{samp_notes}}{is a \code{data.frame} that provides annotations. If DE is to be
run (i.e., \code{!is.null(de_results)}), \code{samp_notes} must have
the grouping_var column, with containing base_level factor, and it must have a control_var
column.}

\item{\code{grouping_var}}{is the column in the annotations data.frame (i.e., \code{samp_notes})
to use for grouping. This is the level 2 factor in the Mixed Effects model for which estimates
are made. This can be a global object generated from \code{read_config()} if running
the Hydra pipeline.}

\item{\code{base_level}}{is a level in the \code{grouping_var} column used as base. This can be
a global object generated from \code{read_config()} if running the Hydra pipeline.}

\item{\code{control_var}}{is the column name in the annotations data.frame (i.e., \code{samp_notes})
used at the level 1 random effect. For DSP, this is usually an individual ID for which several
AOIs are nest within. If it is invariable (e.g., a vector of 1s), the default behavor is to run
a linear model using R's base::lm function. Otherwise, a Mixed-effects model will be used via
lme4::lmer.}

\item{\code{de_dir}}{the parent directory to store the de_results}

\item{\code{n_processors}.}{The number of processors to use. Default is 4.}

\item{\code{the_formula}.}{Either the classic formula (default) or a custom formula. Do to customization possibilities,
there is no guarantee that this will run, converge, or make sense. Example of custom formula =
'a_gene ~ Disease * Tissue + (1 + Disease | DSP_scan)'. Note that 'a_gene' should be left as is.}

\item{\code{show_pb}.}{Logical to show the progress bar (TRUE) or not (FALSE). Default is TRUE.}

\item{\code{min_sample_size}.}{An integer of 1 or more than specifies the minimum number of samples
needed in a group for that group to be used in DE. This is similar to the IO360 report parameter
\code{minSampleSize}. Default is 3.}
}
\value{
Objects and files returned depend on the input:
\enumerate{
   \item{If \code{the_formula=="classic"}, an object of class \code{data.frame} is returned. The
   dataframe is also sent to disk.}
   \item{Otherwise, a list of list is return (see details)}
}
}
\description{
Wrapper function to run differential expression in parallel. This function
is used prior to \code{\link{dsp_de_analysis}}.
}
\details{
The function strips down the main \code{\link{dsp_de_analysis}} function and performs the
differential expression analysis over a specified number of processors. It uses parallel::parLapply to process the
normalized expression for each gene across different groups of interest (i.e., as specified by the \code{grouping_var}
object). By default, this function runs the same as \code{\link{dsp_de_analysis}} in terms of the formulas used.
If the \code{control_var} column is invariant. A simple linaer model will be used. Otherwise, a Mixed effects model
will be used of the form 'a_gene ~ grouping_var + (1 + grouping_var | control_var)'. In both of these scenarios,
a data.frame will be saved to disk and returned. If, however,  \code{the_formula} differs from
its default value of "classic", a custom formula will be used. In such a case, a list of list where the final list
provides the 1) gene, the 2) test (e.g., 'normal vs disease'), and the model. There is no error checking for convergence
etc. if the_formual != "classic". In all Mixed effect models, REML=TRUE.
}
\examples{

# Simulate 2 genes in log2 space. Look at the true fold
# change (for gene_a) and compare to the estimated fold change.
n_samples <- 50
n_aois <- 10
constant <- 4.5
# Simulate normalized, log2
make_aois <- function(mu, sd, n_aois, group){
 out <- data.frame(Group=rep(group, n_aois),
     gene_a=rnorm(n=n_aois, mean=mu, sd=sd))
     return(out)
}
# Different effect size of group A from mean
diff_a <- rnorm(n=n_samples, mean=2, sd=1)
# Make samples.
A <- do.call(rbind, lapply(1:n_samples, function(i){
 samp <- make_aois(constant+diff_a[i], 1, n_aois, "A")
 samp$ind <- i
 return(samp)
}))
diff_b <- rnorm(n=n_samples, mean=-2, sd=1)
B <- do.call(rbind, lapply(1:n_samples, function(i){
 samp <- make_aois(constant+diff_b[i], 1, n_aois, "B")
 samp$ind <- i+max(A$ind)
 return(samp)
}))
df <- rbind(A, B)
require(plyr)
require(dplyr)
df <- ddply(df, .(Group, ind), function(x){
 x$aoi <- 1:nrow(x)
 return(x)
})
df <- df \%>\% mutate(Sample_ID=paste(Group, ind, aoi, sep="_"), gene_b=gene_a+rnorm(1))
# Make sure there's no negative values.
df$gene_a[which(df$gene_a<=0)] <- 1e-03
df$gene_b[which(df$gene_b<=0)] <- 1e-03
library(tidyr)
norms <- rbind(spread(df \%>\% dplyr::select(-aoi, -gene_b, -Group, -ind), Sample_ID, gene_a),
 spread(df \%>\% dplyr::select(-aoi, -gene_a, -Group, -ind), Sample_ID, gene_b))
# "Convert" to linear scale since the function will log2 transform internally
norms <- 2^norms
# Combine
norms <- cbind(data.frame(Gene=c("gene_a", "gene_b")), norms)
row.names(norms) <- norms$Gene
# Convert the df to respective dataframes
annotations <- df \%>\% select(Sample_ID, Group, ind)
library(ggplot2)
ggplot(df, aes(x=factor(ind), y=gene_a)) +
geom_jitter(height=0) + ylab("log2 expression for simulated gene_a")
# Means of the groups in log2 space
means <- ddply(df, .(Group), summarize, mean(gene_a))[,2]
# Fold change where vec is the means in log2 space
# returns FC in linear space
calc_fc <- function(vec){
 vec2 <- 2^vec
 return(vec2[2] / vec2[1])
}
# This is the simulated fold change in log2 space
print(log2(calc_fc(means)))
#Compare that fold change to the estimate for gene_a
library(dspNgs)
dsp_de_analysis_parallel(de_results=NULL, norm_counts=norms,
samp_notes=annotations, grouping_var="Group", base_level="A",
 control_var="ind", de_dir="./", n_processors=4, the_formula="classic")
# End run.
}
\seealso{
\code{\link{dsp_de_analysis}} for plotting.
}
\author{
Tyler Hether
}
